import math

#function get_link_v
def get_link_v(v,D):
    for i, weight in enumerate(D[v]): # формирует список, путем того, что берется строка из матрицы смежности (D[v]) -
        # т.е. она показывает, с какими вершинами связана текущая вершина)
        if weight > 0:
            yield i #возвращаем номер вершины


def arg_min(T,S):
    amin = -1 #номер вершин для которой было посчитано минимальное значение, если она -1, значит мы просмотрели все вершины,
    # и алгоритм должен быть завершен
    m = max(T)#максимальное значение в T ( для упрощения ?
    for i, t in enumerate(T):# перебираем строку таблицы
        if t < m and i not in S:# и ищем минимальное значение тех вершин, которых мы еще не рассматривали
            m = t #сохраняем это минимальное значение
            amin = i #сохраняем индекс этого минимального значение(номер вершины)

    return amin
D = [
    [0, 3, 1, 3, 0, 0],
    [3, 0, 4, 0, 0, 0],
    [1, 4, 0, 0, 7, 5],
    [3, 0, 0, 0, 0, 2],
    [0, 0, 7, 0, 0, 4],
    [0, 0, 5, 2, 4, 0],
]

N = len(D) # numbers of vertex in graph-количество строк в данном случае
T = [math.inf] * N #последняя строка таблицы -  все бесколнечности(таблица с бесконечностями)

v = 0 #  стартовая вершина(нумерация с нуля), так как сдвигается на -1
S = {v} #просмотренные вершины, множество, которое хранит вершины.( записывается только одна пока стартовая вершина)
T[v] = 0 # нулевой вес для стартовой вершины (таблица с бесконечностями)
way = []#путь, который необходимо найти в задании



while v != -1:# цикл, пока не просмотрим все вершины
    way.append(v)
    for j in get_link_v(v,D):#перебираем все связанные вершины с верщиной v(функция  get_link_v возвращает все вершины,
# которые связанны с рассматриваемой(v in this case)
        if j not in S:# проверка просмотренности

            w = T[v] +D[v][j] #формирование весов для таблицы с инф путем прибавления к начальному весу, веса дуги,
            # который берется из матрицы смежности ( формирование текущего веса связи для j-ой вершины)
            if w <  T[j]:# если вес для j-ой вершины меньше, чем тот, который уже для нее записан, то мы сохраняем новое значение связи
                T[j] = w
                #после того, как эта операция подсчета весов была выполнена для всех вершин j, которые не входили в список S
                #выбор вершины с минимальным весом
                #следующая итерация
    v = arg_min(T,S)
    if v > 0: #где не равно 0 и -1
        S.add(v)# обавляем в рассмотренные вершины



print(T)
print(way)
